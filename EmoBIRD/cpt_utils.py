"""
CPT Utilities: Helper functions for loading and working with CPT data.

This module provides utilities for loading CPT data generated by
NeutralProbabilityExtractor and working with the CPT format.
"""

import json
import os
from typing import Dict, List, Any, Optional


def load_cpt(path: str) -> dict:
    """
    Load CPT data from a JSON file written by NeutralProbabilityExtractor.
    
    Args:
        path: Path to the CPT JSON file
        
    Returns:
        CPT data dictionary with structure:
        {
            "factors": [...],            # list of factor definitions
            "emotions": [...],           # canonical emotion list
            "cpt": {combo_key: {emotion: prob, ...}, ...}
        }
        
    Raises:
        FileNotFoundError: If the CPT file doesn't exist
        ValueError: If the CPT file format is invalid
    """
    if not os.path.exists(path):
        raise FileNotFoundError(f"CPT file not found: {path}")
    
    try:
        with open(path, 'r', encoding='utf-8') as f:
            cpt_data = json.load(f)
        
        # Validate CPT structure
        _validate_cpt_structure(cpt_data)
        
        print(f"âœ… Loaded CPT from {path}")
        print(f"   ðŸ“Š Factors: {len(cpt_data.get('factors', []))}")
        print(f"   ðŸŽ­ Emotions: {len(cpt_data.get('emotions', []))}")
        print(f"   ðŸŽ² CPT entries: {len(cpt_data.get('cpt', {}))}")
        
        return cpt_data
        
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON in CPT file {path}: {e}")
    except Exception as e:
        raise ValueError(f"Error loading CPT file {path}: {e}")


def save_cpt(cpt_data: dict, path: str) -> None:
    """
    Save CPT data to a JSON file.
    
    Args:
        cpt_data: CPT data dictionary
        path: Path where to save the CPT JSON file
    """
    try:
        # Validate structure before saving
        _validate_cpt_structure(cpt_data)
        
        # Ensure directory exists
        os.makedirs(os.path.dirname(path), exist_ok=True)
        
        with open(path, 'w', encoding='utf-8') as f:
            json.dump(cpt_data, f, indent=2, ensure_ascii=False)
        
        print(f"âœ… Saved CPT to {path}")
        
    except Exception as e:
        raise ValueError(f"Error saving CPT file {path}: {e}")


def _validate_cpt_structure(cpt_data: dict) -> None:
    """
    Validate that CPT data has the expected structure.
    
    Args:
        cpt_data: CPT data dictionary to validate
        
    Raises:
        ValueError: If the structure is invalid
    """
    if not isinstance(cpt_data, dict):
        raise ValueError("CPT data must be a dictionary")
    
    # Check required keys
    required_keys = ['factors', 'emotions', 'cpt']
    for key in required_keys:
        if key not in cpt_data:
            raise ValueError(f"Missing required key '{key}' in CPT data")
    
    # Validate factors
    factors = cpt_data['factors']
    if not isinstance(factors, list):
        raise ValueError("CPT 'factors' must be a list")
    
    for i, factor in enumerate(factors):
        if not isinstance(factor, dict):
            raise ValueError(f"Factor {i} must be a dictionary")
        if 'name' not in factor:
            raise ValueError(f"Factor {i} missing 'name' field")
    
    # Validate emotions
    emotions = cpt_data['emotions']
    if not isinstance(emotions, list):
        raise ValueError("CPT 'emotions' must be a list")
    
    # Validate CPT table
    cpt_table = cpt_data['cpt']
    if not isinstance(cpt_table, dict):
        raise ValueError("CPT 'cpt' must be a dictionary")


def get_cpt_info(cpt_data: dict) -> Dict[str, Any]:
    """
    Get summary information about a CPT data structure.
    
    Args:
        cpt_data: CPT data dictionary
        
    Returns:
        Dictionary with CPT information
    """
    factors = cpt_data.get('factors', [])
    emotions = cpt_data.get('emotions', [])
    cpt_table = cpt_data.get('cpt', {})
    
    # Count unique factor values
    total_factor_values = 0
    for factor in factors:
        factor_values = factor.get('values', [])
        total_factor_values += len(factor_values)
    
    # Analyze CPT coverage
    expected_combinations = 1
    for factor in factors:
        expected_combinations *= len(factor.get('values', []))
    
    actual_combinations = len(cpt_table)
    coverage = (actual_combinations / expected_combinations * 100) if expected_combinations > 0 else 0
    
    return {
        'num_factors': len(factors),
        'factor_names': [f['name'] for f in factors],
        'total_factor_values': total_factor_values,
        'num_emotions': len(emotions),
        'emotion_names': emotions,
        'expected_combinations': expected_combinations,
        'actual_combinations': actual_combinations,
        'coverage_percent': round(coverage, 2),
        'metadata': cpt_data.get('metadata', {})
    }


def find_missing_combinations(cpt_data: dict) -> List[Dict[str, str]]:
    """
    Find factor combinations that are missing from the CPT table.
    
    Args:
        cpt_data: CPT data dictionary
        
    Returns:
        List of missing factor combinations
    """
    import itertools
    
    factors = cpt_data.get('factors', [])
    cpt_table = cpt_data.get('cpt', {})
    
    if not factors:
        return []
    
    # Generate all possible combinations
    factor_names = [f['name'] for f in factors]
    factor_value_lists = [f.get('values', []) for f in factors]
    
    all_combinations = []
    for combo in itertools.product(*factor_value_lists):
        combination = dict(zip(factor_names, combo))
        combo_key = str(tuple(combo))
        
        if combo_key not in cpt_table:
            all_combinations.append(combination)
    
    return all_combinations


def create_dummy_cpt(factors: List[str], emotions: List[str], 
                    factor_values: Optional[Dict[str, List[str]]] = None) -> dict:
    """
    Create a dummy CPT for testing purposes.
    
    Args:
        factors: List of factor names
        emotions: List of emotion names
        factor_values: Optional mapping of factor_name to list of values
        
    Returns:
        Dummy CPT data structure
    """
    import random
    
    # Default factor values if not provided
    if factor_values is None:
        factor_values = {factor: ['low', 'medium', 'high'] for factor in factors}
    
    # Build factor definitions
    factor_defs = []
    for factor_name in factors:
        factor_defs.append({
            'name': factor_name,
            'values': factor_values.get(factor_name, ['low', 'high'])
        })
    
    # Generate dummy CPT entries
    import itertools
    
    cpt_table = {}
    factor_value_lists = [factor_values.get(fname, ['low', 'high']) for fname in factors]
    
    for combo in itertools.product(*factor_value_lists):
        combo_key = str(combo)
        
        # Generate random probabilities that sum to 1.0
        raw_probs = [random.random() for _ in emotions]
        total_prob = sum(raw_probs)
        normalized_probs = [p / total_prob for p in raw_probs]
        
        emotion_probs = dict(zip(emotions, normalized_probs))
        cpt_table[combo_key] = emotion_probs
    
    dummy_cpt = {
        'factors': factor_defs,
        'emotions': emotions,
        'cpt': cpt_table,
        'metadata': {
            'method': 'dummy_generation',
            'purpose': 'testing',
            'num_combinations': len(cpt_table),
            'num_factors': len(factors),
            'num_emotions': len(emotions)
        }
    }
    
    return dummy_cpt
